# 🧭 Sesión 3 · Punto 2 — Encapsulación y abstracción básica

## 🎯 Objetivos específicos

* Entender el concepto de **encapsulación** en Python.
* Diferenciar entre atributos/métodos públicos, protegidos y privados.
* Introducir la **abstracción** con clases base y métodos abstractos.
* Aplicar estos conceptos en un diseño simple de clases.

---

## 📚 Resumen teórico-práctico

### 🔹 Encapsulación en Python

Python no tiene modificadores de acceso estrictos como Java o C#, pero sigue una **convención de nombres**:

* **Público**: acceso libre.

  ```python
  self.nombre
  ```

* **Protegido** (convención): un guion bajo.

  ```python
  self._saldo
  ```

  👉 Indica “uso interno”, pero se puede acceder desde fuera si se fuerza.

* **Privado** (name mangling): doble guion bajo.

  ```python
  self.__password
  ```

  👉 Python renombra internamente → `_Clase__password`.

Ejemplo:

```python
class Cuenta:
    def __init__(self, titular, saldo):
        self.titular = titular    # público
        self._saldo = saldo       # protegido
        self.__password = "1234"  # privado

    def get_saldo(self, pwd):
        if pwd == self.__password:
            return self._saldo
        else:
            raise PermissionError("Contraseña incorrecta")
```

---

### 🔹 Getters y setters (propiedades en Python)

En lugar de métodos `get/set`, se usan **`@property`** y **`@atributo.setter`**:

```python
class Producto:
    def __init__(self, nombre, precio):
        self._precio = precio
        self.nombre = nombre

    @property
    def precio(self):
        return self._precio

    @precio.setter
    def precio(self, nuevo_precio):
        if nuevo_precio < 0:
            raise ValueError("El precio no puede ser negativo")
        self._precio = nuevo_precio
```

Uso:

```python
p = Producto("Teclado", 20)
print(p.precio)   # 20
p.precio = 25     # setter validado
```

---

### 🔹 Abstracción con clases base

Permite definir una interfaz que obliga a implementar ciertos métodos en las subclases.

```python
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangulo(Figura):
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto

    def area(self):
        return self.ancho * self.alto
```

Uso:

```python
f = Rectangulo(5, 10)
print(f.area())  # 50
```

👉 No puedes instanciar `Figura` directamente porque tiene un método abstracto.

---

## 🧩 Mini-ejercicios rápidos

1. Crea una clase `CuentaBancaria` con un atributo protegido `_saldo` y un método `depositar`. Añade un método `retirar` que valide que no se quede en negativo.
2. Define una clase `Vehiculo` como abstracta con método `mover()`. Implementa `Coche` y `Bicicleta` que hereden de ella.
3. Implementa `@property` en una clase `Empleado` para que el atributo `salario` nunca pueda ser menor que 1000.

---

## ✅ Checklist de dominio

* [ ] ¿Sé diferenciar entre atributos públicos, protegidos y privados en Python?
* [ ] ¿Sé aplicar `@property` para encapsular la lógica de acceso a atributos?
* [ ] ¿Entiendo que las clases abstractas no se pueden instanciar directamente?
* [ ] ¿Puedo obligar a que una subclase implemente ciertos métodos con `@abstractmethod`?