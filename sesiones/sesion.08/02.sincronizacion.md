# ðŸ§­ SesiÃ³n 8 Â· Punto 2 â€” SincronizaciÃ³n en Multiprocesamiento

## ðŸŽ¯ Objetivos especÃ­ficos

* Entender quÃ© es una **condiciÃ³n de carrera** en el contexto de procesos.
* Aprender a usar **`multiprocessing.Lock`** para proteger recursos compartidos.
* Ver ejemplos de **errores tÃ­picos** cuando varios procesos modifican memoria compartida sin sincronizaciÃ³n.
* Conocer **buenas prÃ¡cticas** para evitar bloqueos y garantizar consistencia.

---

## ðŸ“š Resumen teÃ³rico-prÃ¡ctico

### ðŸ”¹ Condiciones de carrera en procesos

Ocurren cuando dos o mÃ¡s procesos intentan acceder/modificar **un recurso compartido** (archivo, variable en memoria, registro en DB) **al mismo tiempo** sin coordinaciÃ³n.

Ejemplo clÃ¡sico: contador compartido.

---

### ðŸ”¹ Uso de `Value` y `Array` con `Lock`

```python
from multiprocessing import Process, Value, Lock

def incrementar(contador, lock):
    for _ in range(100000):
        with lock:
            contador.value += 1

if __name__ == "__main__":
    lock = Lock()
    contador = Value('i', 0)  # entero compartido

    procesos = [Process(target=incrementar, args=(contador, lock)) for _ in range(4)]
    for p in procesos: p.start()
    for p in procesos: p.join()

    print("Contador final:", contador.value)  # esperado: 400000
```

ðŸ‘‰ Sin el `with lock:`, el valor final puede ser **incorrecto** (condiciÃ³n de carrera).

---

### ðŸ”¹ Locks en acceso a archivos compartidos

```python
from multiprocessing import Process, Lock
from pathlib import Path

def escribir_log(lock, path, mensaje):
    with lock:  # protege la escritura concurrente
        with Path(path).open("a", encoding="utf-8") as f:
            f.write(mensaje + "\n")

if __name__ == "__main__":
    lock = Lock()
    archivo = "log.txt"
    procesos = [
        Process(target=escribir_log, args=(lock, archivo, f"Proceso {i}"))
        for i in range(5)
    ]
    for p in procesos: p.start()
    for p in procesos: p.join()
```

ðŸ‘‰ Sin `lock`, las lÃ­neas pueden mezclarse o truncarse.

---

### ðŸ”¹ Buenas prÃ¡cticas con multiprocesamiento

1. Usar `with lock:` siempre que haya recurso **compartido mutable**.
2. Reducir al mÃ­nimo el **tiempo dentro de la secciÃ³n crÃ­tica**.
3. Evitar locks anidados innecesarios â†’ riesgo de **deadlock**.
4. Si se necesita reentrada, usar `RLock`.
5. Para casos complejos, preferir **colas (`Queue`)** antes que memoria compartida.

---

## ðŸ§© Mini-ejercicios rÃ¡pidos

1. Implementa un **contador global** con 5 procesos incrementando a la vez: prueba **con y sin lock** y compara resultados.
2. Haz que 3 procesos escriban al mismo archivo de log con y sin lock; observa cÃ³mo se intercalan o corrompen las lÃ­neas.
3. Extiende el ejercicio para usar **`Array('i', [0,0,0])`** y que cada proceso incremente un Ã­ndice distinto.

---

## âœ… Checklist de dominio

* [ ] Â¿Puedo explicar quÃ© es una condiciÃ³n de carrera en procesos?
* [ ] Â¿SÃ© usar `multiprocessing.Value` y `multiprocessing.Array` para compartir datos?
* [ ] Â¿Protejo correctamente el acceso con `Lock`?
* [ ] Â¿Evito bloqueos prolongados o deadlocks al diseÃ±ar mis secciones crÃ­ticas?
* [ ] Â¿SÃ© cuÃ¡ndo preferir comunicaciÃ³n con `Queue` en lugar de memoria compartida?