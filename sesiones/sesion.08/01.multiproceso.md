# ðŸ§­ SesiÃ³n 8 Â· Punto 1 â€” Multiprocesamiento en Python

## ðŸŽ¯ Objetivos especÃ­ficos

* Entender la diferencia entre **hilos (concurrency I/O)** y **procesos (paralelismo CPU)**.
* Usar el mÃ³dulo `multiprocessing` para ejecutar tareas en paralelo.
* Aprender a comunicar procesos mediante **`Queue`**.
* Introducir el uso de **`Pool`** para simplificar la gestiÃ³n de mÃºltiples procesos.

---

## ðŸ“š Resumen teÃ³rico-prÃ¡ctico

### ðŸ”¹ Hilos vs Procesos en Python

* **Hilos (`threading`)** â†’ comparten memoria dentro de un proceso; limitados por el **GIL**; Ãºtiles para tareas de **I/O**.
* **Procesos (`multiprocessing`)** â†’ cada proceso tiene su propia memoria y evita el GIL; Ãºtiles para tareas **CPU intensivo** (cÃ¡lculo, ML, procesamiento de imÃ¡genes).

---

### ðŸ”¹ Uso bÃ¡sico de `Process`

```python
from multiprocessing import Process
import os, time

def tarea(nombre):
    print(f"Proceso {nombre} (PID={os.getpid()}) trabajandoâ€¦")
    time.sleep(1)
    print(f"Proceso {nombre} terminado")

if __name__ == "__main__":
    p1 = Process(target=tarea, args=("A",))
    p2 = Process(target=tarea, args=("B",))
    p1.start(); p2.start()
    p1.join(); p2.join()
    print("âœ” Todos los procesos han finalizado")
```

ðŸ‘‰ Cada proceso tiene su **PID independiente**.

---

### ðŸ”¹ ComunicaciÃ³n entre procesos con `Queue`

```python
from multiprocessing import Process, Queue

def productor(q):
    for i in range(5):
        q.put(i)
    q.put(None)  # seÃ±al de terminaciÃ³n

def consumidor(q):
    while True:
        item = q.get()
        if item is None:
            break
        print(f"Consumido: {item}")

if __name__ == "__main__":
    q = Queue()
    p1 = Process(target=productor, args=(q,))
    p2 = Process(target=consumidor, args=(q,))
    p1.start(); p2.start()
    p1.join(); p2.join()
```

ðŸ‘‰ `Queue` permite pasar datos entre procesos de manera **segura**.

---

### ðŸ”¹ Uso de `Pool` para mapear funciones

```python
from multiprocessing import Pool
import time

def cuadrado(x):
    time.sleep(1)
    return x * x

if __name__ == "__main__":
    with Pool(processes=4) as pool:
        numeros = [1, 2, 3, 4, 5, 6]
        resultados = pool.map(cuadrado, numeros)
    print("Resultados:", resultados)
```

ðŸ‘‰ `Pool` gestiona automÃ¡ticamente los procesos y permite aplicar funciones en paralelo.

---

## ðŸ§© Mini-ejercicios rÃ¡pidos

1. Escribe un programa con 3 procesos que calculen la suma de distintos rangos de nÃºmeros y pasen el resultado a un `Queue`. El proceso principal debe sumar los resultados parciales.
2. Usa un `Pool` de 4 procesos para calcular los factoriales de una lista de nÃºmeros grandes (`math.factorial`).
3. Modifica el ejemplo del productor-consumidor para que el productor genere palabras desde un archivo de texto y el consumidor las cuente.

---

## âœ… Checklist de dominio

* [ ] Â¿Entiendo la diferencia entre hilos y procesos en Python?
* [ ] Â¿SÃ© crear procesos manualmente con `Process`?
* [ ] Â¿SÃ© comunicar procesos con `Queue`?
* [ ] Â¿SÃ© usar un `Pool` para mapear funciones en paralelo?
* [ ] Â¿Tengo claro cuÃ¡ndo usar **multiprocesamiento** (CPU-bound) frente a **multihilos** (I/O-bound)?