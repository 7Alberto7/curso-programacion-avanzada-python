# 🧭 Sesión 4 · Punto 2 — Uso de `super()`

## 🎯 Objetivos específicos

* Comprender qué hace `super()` en Python.
* Aprender a reutilizar y extender métodos de la clase base.
* Aplicar `super()` en **constructores** (`__init__`) y en métodos sobreescritos.
* Analizar cómo interactúa con la **herencia múltiple** y el MRO.

---

## 📚 Resumen teórico-práctico

### 🔹 `super()` en constructores

Permite inicializar correctamente atributos de la clase base sin repetir código.

```python
class Usuario:
    def __init__(self, nombre, email):
        self.nombre = nombre
        self.email = email

class Admin(Usuario):
    def __init__(self, nombre, email, permisos):
        super().__init__(nombre, email)  # inicializa parte de Usuario
        self.permisos = permisos
```

Uso:

```python
a = Admin("Ana", "ana@test.com", ["borrar", "crear"])
print(a.nombre, a.email, a.permisos)
```

---

### 🔹 `super()` en métodos sobreescritos

Permite añadir lógica **antes o después** del método de la clase padre.

```python
class Logger:
    def log(self, msg):
        print("[LOG]", msg)

class LoggerTiempo(Logger):
    def log(self, msg):
        from datetime import datetime
        super().log(f"{datetime.now()} - {msg}")
```

Uso:

```python
l = LoggerTiempo()
l.log("Usuario creado")
```

---

### 🔹 `super()` en herencia múltiple

Con MRO, `super()` **no siempre apunta a la clase padre inmediata**, sino a la siguiente en el orden de resolución.

```python
class A:
    def saludar(self): print("A")

class B(A):
    def saludar(self):
        print("B antes")
        super().saludar()
        print("B después")

class C(A):
    def saludar(self):
        print("C antes")
        super().saludar()
        print("C después")

class D(B, C):
    def saludar(self):
        print("D")
        super().saludar()

d = D()
d.saludar()
print(D.mro())
```

Salida esperada:

```
D
B antes
C antes
A
C después
B después
```

👉 Aquí `super()` respeta el MRO: D → B → C → A.

---

## 🧩 Mini-ejercicios rápidos

1. Extiende la clase `Usuario` (del Lab 3) con una subclase `Moderador`. Haz que su `__init__` use `super()` para inicializar nombre/email/rol, y añada un campo `nivel`.
2. Crea una clase `Logger` y otra `LoggerDebug`. Sobreescribe `log()` en `LoggerDebug` para añadir un prefijo `[DEBUG]` usando `super()`.
3. Diseña un diamante simple (A → B, A → C, D hereda de B y C) y observa el orden de ejecución con `super()` y `print()`.

---

## ✅ Checklist de dominio

* [ ] ¿Sé usar `super().__init__()` para inicializar correctamente subclases?
* [ ] ¿Puedo extender métodos existentes sin reescribir toda la lógica?
* [ ] ¿Entiendo que en herencia múltiple, `super()` sigue el **MRO**, no solo “el padre inmediato”?
* [ ] ¿Sé imprimir `Clase.mro()` para entender cómo fluye `super()`?