# 🧭 Sesión 6 · Punto 2 — `unittest`, `assert` y buenas prácticas

## 🎯 Objetivos específicos

* Aprender a usar el módulo estándar **`unittest`** de Python.
* Escribir **casos de prueba estructurados** en clases que extienden `unittest.TestCase`.
* Usar correctamente **`assert`** y los métodos de aserción (`assertEqual`, `assertTrue`, `assertRaises`...).
* Conocer **buenas prácticas** para mantener un conjunto de tests legible y mantenible.

---

## 📚 Resumen teórico-práctico

### 🔹 Estructura básica con `unittest`

```python
import unittest

class TestMatematica(unittest.TestCase):
    def test_suma(self):
        self.assertEqual(2 + 2, 4)

    def test_division_por_cero(self):
        with self.assertRaises(ZeroDivisionError):
            _ = 1 / 0

if __name__ == "__main__":
    unittest.main()
```

👉 Cada método que empieza por `test_` será ejecutado como prueba.

---

### 🔹 Métodos de aserción más usados

* `assertEqual(a, b)` → `a == b`.
* `assertNotEqual(a, b)` → `a != b`.
* `assertTrue(x)` / `assertFalse(x)`.
* `assertIn(elem, contenedor)` / `assertNotIn(...)`.
* `assertIsNone(x)` / `assertIsNotNone(x)`.
* `assertRaises(exc, func, *args)` → espera una excepción.

---

### 🔹 Organización de tests

* Los tests suelen ir en carpeta `tests/`.
* Un archivo por módulo a probar, ej. `test_modelos.py`.
* Se pueden ejecutar todos juntos:

  ```bash
  python -m unittest discover -s tests
  ```

---

### 🔹 Ejemplo aplicado (sistema de usuarios)

**tests/test\_modelos.py**

```python
import unittest
from app.modelos import Usuario, Admin, Moderador
from app.repositorio import RepositorioUsuarios

class TestUsuario(unittest.TestCase):
    def test_presentarse(self):
        u = Usuario("Ana", "ana@test.com")
        self.assertEqual(u.presentarse(), "Soy Ana (ana@test.com)")

    def test_email_invalido(self):
        with self.assertRaises(ValueError):
            Usuario("Luis", "sin-arroba")

    def test_password_check(self):
        u = Usuario("Ana", "ana@test.com")
        u.set_password("secreta1")
        self.assertTrue(u.check_password("secreta1"))
        self.assertFalse(u.check_password("otra"))

class TestRoles(unittest.TestCase):
    def test_admin_permisos(self):
        a = Admin("Root", "root@corp.com")
        self.assertIn("borrar", a.permisos())

    def test_moderador_nivel(self):
        m = Moderador("Lucía", "lucia@test.com", nivel=2)
        self.assertIn("borrar", m.permisos())

class TestRepositorio(unittest.TestCase):
    def test_agregar_y_obtener(self):
        repo = RepositorioUsuarios()
        u = Usuario("Ana", "ana@test.com")
        repo.agregar(u)
        self.assertEqual(repo.obtener_por_email("ana@test.com"), u)

    def test_duplicados(self):
        repo = RepositorioUsuarios()
        u1 = Usuario("Ana", "ana@test.com")
        u2 = Usuario("Ana2", "ana@test.com")
        repo.agregar(u1)
        with self.assertRaises(ValueError):
            repo.agregar(u2)

if __name__ == "__main__":
    unittest.main()
```

---

### 🔹 Buenas prácticas

* **Nombres claros** en métodos: `test_email_invalido`, no `test1`.
* **Independencia**: cada test debe funcionar sin depender del orden de ejecución.
* **Datos simples y controlados**: evita dependencias externas salvo mocks.
* **Cobertura balanceada**: probar tanto casos esperados como errores/excepciones.
* **Automatización**: integrarlos en CI/CD (`pytest` o `unittest` en pipelines).

---

## 🧩 Mini-ejercicios rápidos

1. Crea un test que verifique que `Moderador(nivel=1)` **no** tiene permiso `"borrar"`.
2. Escribe un test que compruebe que `RepositorioUsuarios.eliminar(email)` elimina efectivamente al usuario.
3. Haz un test que valide que `Usuario.contador` aumenta cada vez que se crea una instancia.

---

## ✅ Checklist de dominio

* [ ] ¿Sé estructurar un archivo de tests con clases y métodos `test_*`?
* [ ] ¿Uso las aserciones de `unittest` en lugar de `print`?
* [ ] ¿Mis tests son independientes y claros en sus nombres?
* [ ] ¿Comprendo cómo ejecutar todos los tests con `unittest discover`?