# ðŸ§­ SesiÃ³n 7 Â· Punto 2 â€” Locks y Deadlocks

## ðŸŽ¯ Objetivos especÃ­ficos

* Comprender quÃ© es un **Lock** y cÃ³mo evita condiciones de carrera.
* Conocer la diferencia entre **bloqueo simple** (`Lock`) y **reentrante** (`RLock`).
* Entender quÃ© es un **deadlock**, cÃ³mo se produce y cÃ³mo prevenirlo.
* Practicar patrones de uso seguro de locks.

---

## ðŸ“š Resumen teÃ³rico-prÃ¡ctico

### ðŸ”¹ Â¿QuÃ© es un Lock?

Un **Lock** es un mecanismo de sincronizaciÃ³n que asegura que **solo un hilo accede a un recurso compartido a la vez**.

Ejemplo: incrementar un contador global desde varios hilos.

```python
import threading

contador = 0
lock = threading.Lock()

def incrementar():
    global contador
    for _ in range(100000):
        with lock:     # exclusiÃ³n mutua
            contador += 1
```

ðŸ‘‰ Sin `with lock`, el valor final puede ser menor al esperado por condiciones de carrera.

---

### ðŸ”¹ Lock vs RLock

* `Lock`: si un hilo intenta adquirirlo dos veces seguidas â†’ **se bloquea**.
* `RLock` (Reentrant Lock): permite que el mismo hilo lo adquiera mÃºltiples veces sin bloquearse (lleva un contador interno).

```python
lock = threading.Lock()
rlock = threading.RLock()
```

---

### ðŸ”¹ Deadlock (interbloqueo)

Ocurre cuando dos o mÃ¡s hilos esperan **indefinidamente** porque cada uno mantiene un lock y necesita otro.

Ejemplo clÃ¡sico:

```python
import threading, time

lock1 = threading.Lock()
lock2 = threading.Lock()

def tarea1():
    with lock1:
        time.sleep(1)
        with lock2:
            print("Tarea1 completada")

def tarea2():
    with lock2:
        time.sleep(1)
        with lock1:
            print("Tarea2 completada")

t1 = threading.Thread(target=tarea1)
t2 = threading.Thread(target=tarea2)

t1.start(); t2.start()
t1.join(); t2.join()
```

ðŸ‘‰ AquÃ­ ambos hilos pueden quedar **bloqueados para siempre** (cada uno espera el lock del otro).

---

### ðŸ”¹ CÃ³mo prevenir deadlocks

1. **Orden global de adquisiciÃ³n de locks** â†’ todos los hilos adquieren locks en el mismo orden.
2. Usar **timeout** al adquirir un lock:

   ```python
   if lock.acquire(timeout=2):
       try:
           # trabajo protegido
           ...
       finally:
           lock.release()
   else:
       print("No se pudo adquirir lock, evitando deadlock")
   ```
3. Usar **RLock** cuando un hilo pueda necesitar el mismo lock varias veces.

---

## ðŸ§© Mini-ejercicios rÃ¡pidos

1. Implementa un contador global con 3 hilos incrementando 50.000 veces cada uno:

   * **sin lock** â†’ muestra valores inconsistentes.
   * **con lock** â†’ siempre el valor esperado.

2. Simula un deadlock con dos locks (`lock1`, `lock2`) y dos hilos que los adquieren en orden distinto.

3. Modifica el ejercicio 2 para **prevenir el deadlock**:

   * Todos adquieren locks en el mismo orden (`lock1` â†’ `lock2`).
   * O usa `acquire(timeout=â€¦)` y maneja el fallo.

---

## âœ… Checklist de dominio

* [ ] Â¿SÃ© usar `Lock` para proteger secciones crÃ­ticas?
* [ ] Â¿Entiendo cuÃ¡ndo es necesario un `RLock`?
* [ ] Â¿Puedo explicar quÃ© es un deadlock y dar un ejemplo sencillo?
* [ ] Â¿Conozco al menos dos estrategias para evitar deadlocks?